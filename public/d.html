<!doctype html>
<html>
  <head>
    <title>Socket.IO chat</title>
   
  </head>
  <script src="/socket.io/socket.io.js"></script>
  <script src="./js/moment.min.js"></script>
  <script src="./js/Chart.min.js"></script>
  <link rel="stylesheet" href="./css/s.css"/>

  <script>
const postBody = (f) => 
{
  return {      
		"parent":"device_id",
		"parentVal":f.device_id,
		"index": 'sensor_id',
        "value": f.sensor,
        "from": f.to - (f.interval * 10) ,
        "to": f.to,
        "access_token": '5uU2wtti88oHDqow5UUoPX' 
      }
}
var moment ;

class Graphs{
  constructor(init,label,data){
    //details
    this.sensor = init.sensor;
    this.device_id = init.device_id;
    
    //buffer
    this.needBuff = false;
    this.data = data;                     
    this.label = label;                   
    this.to = label[label.length -1]      
    this.from = label[0];                 
    
    // view
    this.live = true;
    this.interval = init.interval;
    this.indexFrom = this.label.findIndex(time => time > this.to - this.interval);
    this.indexTo = this.label.length -1;

    this.chart = new Chart(document.getElementById(init.canvas), 
          this.setConfig(init.canvas,[],[]));

    this.updateGraphView();

    var nn = init.canvas + "i";
    var config = this.setConfig(nn,this.data,this.label);
    const minPoint = Math.min(...this.data);
    config.options.legend.display = false;
    config.options.animation = {duration : 0};
    config.options.hover = {animationDuration : 0};
    config.options.responsiveAnimationDuration = 0;

    config.options.scales.yAxes = [{ticks: { suggestedMin: minPoint, } }];
    config.data.datasets[0].borderWidth =  0.1;
    let colors = []
    for(var i in this.label){
      if(i >= this.indexFrom && i <= this.indexTo){
        colors.push("yellow")
      } else colors.push("black")
    }
    config.data.datasets[0].pointBackgroundColor = colors
    config.data.datasets[0].backgroundColor = colors
    config.data.datasets[0].fill = false;
    config.data.datasets[0].showLine = false;
    this.chart2 = new Chart(document.getElementById(nn), config);

  }
  goLive(){
    this.indexTo = this.label.length -1
    this.indexFrom = this.label.findIndex(time => time > this.to - this.interval);
    this.live = true;
    this.updateGraphView();
  }
  setInterval(e){
    this.interval = e;
    this.goLive();
    this.updateBufferColors();
  }
  updateBuffer(label,data){
    const bufferLength = label.length;
    const oldexFrom = this.label[this.indexFrom]
    const oldexTo = this.label[this.indexTo]

    this.data = [...data,...this.data];
    this.label = [...label,...this.label];
    this.indexFrom = this.label.findIndex(time => time === oldexFrom);
    this.indexTo = this.label.findIndex(time => time === oldexTo);
    this.needBuff = false;
    this.updateBufferView(this.data,this.label);
    this.updateBufferColors()
  }
  updateBufferColors(){
    var colors = []
    for(var i in this.label){
      if(i >= this.indexFrom && i <= this.indexTo){
        colors.push("yellow")
      } else colors.push("black")
    }
    this.chart2.data.datasets[0].pointBackgroundColor = colors;
    this.chart2.update(1000);
  }
  updateBufferView(){
    this.chart2.config.data.datasets.forEach((dataset) => {
        dataset.data = this.data;
    });   
    this.chart2.config.data.labels = this.label;
    this.chart2.update(100);
  }
  updateGraphView(){
    this.chart.config.data.labels = this.label.slice(this.indexFrom,this.indexTo);
    this.chart.config.data.datasets.forEach((dataset) => {
        dataset.data = this.data.slice(this.indexFrom,this.indexTo);
    });
    this.chart.update(100);
  }

  moveOnGraph(x){
    const newval = Math.floor((this.indexTo - this.indexFrom) * x);
    const newto = this.indexTo + newval;
    const newfrom =  this.indexFrom + newval

    if(this.indexFrom < this.label.length / 5){
      console.log("need buff", )
      this.needBuff = true;
    }
    
    if(this.indexTo > this.label.length -1 && newval > 0){  
      this.live = true;
      console.log("live")
    }else if (this.indexFrom <= 0 && newval < 0){
      console.log("stap");
    }else if(!this.needBuff){
      this.live = false;
      this.indexTo = this.indexTo + newval;
      this.indexFrom = this.indexFrom + newval;
      this.updateBufferColors()
    }

    this.updateGraphView()
  }

  pushPoint(x,y){
      this.label = [...this.label,x];
      this.data = [...this.data,y];
      console.log(this.live)
      if(this.live){
        this.indexFrom = this.indexFrom + 1;
        this.indexTo = this.indexTo + 1;
        this.updateGraphView();
      }
  } 

  setConfig(name, data,label){
    return {
      nameItem: name,
      type: 'line',
      data: {
        labels: label,
        datasets: [{
          type: "line",
          fill:false,
          label: name,
          data: data,
          pointBackgroundColor : "black",
          backgroundColor : [],
          fillColors : "green",
          borderWidth: 4
        }]
      }, options: {
        ticks : {
          source : "labels",
        },
        legend : {
          display : true
        },
        scales: {
          xAxes: [{
            type : "time",
            fontSize : 30
            }],
          yAxes: [{
            display: true,
            ticks: {
                suggestedMin: 0,    // minimum will be 0, unless there is a lower value.
                suggestedMax : 40,
                stepSize: 2
            }
          }]
        },
        tooltips: {
          enabled : false
        }
      }
    };
  };
}

async function postData(url, data) {
  // Default options are marked with *
  return fetch(url, {
    body: JSON.stringify(data), // must match 'Content-Type' header
    cache: 'force-cache', // *default, no-cache, reload, force-cache, only-if-cached
    credentials: 'same-origin', // include, same-origin, *omit
    headers: {
      'user-agent': 'Mozilla/4.0 MDN Example',
      'content-type': 'application/json'
    },
    method: 'POST', // *GET, POST, PUT, DELETE, etc.
    mode: 'cors', // no-cors, cors, *same-origin
    redirect: 'follow', // manual, *follow, error
    referrer: 'no-referrer', // *client, no-referrer
  })
  .then(response => response.json()) // parses response to JSON
}
var g = {};

function setInterval(e){
  g.setInterval(e);
};

function goLive(){
  g.goLive();
}

function push(){
    g.pushPoint(Date.now(), 25);
}

window.onload = async function(){
  var initerval = document.getElementById("timeScale").value
  
  var init = {
    device_id : "pi0-10",
    sensor : "am2302H",
    interval : initerval,
    canvas : "asd",
    to : Date.now(),
  }

  post =  postBody(init);
  
  data = await postData('query/feedsByIndex', post).catch(error => console.error(error))
  // console.log(data)
  values = data.map(d => d.data);
  labels = data.map(d => d.timeS);
  
  g = new Graphs(init,labels,values);
  
  canvas  = document.getElementById(init.canvas);
  canvas.onmousedown = async function(e){
    canvasHalf = canvas.width/2;
    intervalDelta = e.x - canvasHalf;
    x = (1 - ((canvas.width -  intervalDelta) / canvas.width))* 2; 
    g.moveOnGraph(x);
    
    if(g.needBuff){
      var p = init;
      p.to = g.label[0];
      
      data = await postData('query/feedsByIndex', postBody(p)).catch(error => console.error(error))
      values = data.map(d => d.data);
      labels = data.map(d => d.timeS);
      
      g.updateBuffer(labels,values);
    }
  }
  canvas.onmousemove = async function(e){
    // var canvas = document.getElementById('asd');
    // canvasHalf = canvas.width/2;
    // intervalDelta = e.x - canvasHalf;
    // x = (1 - ((canvas.width -  intervalDelta) / canvas.width))* 2; 
    // x = Math.abs(x);

    // var ctx = canvas.getContext('2d');
        
    // ctx.fillStyle = "blue";
                
    // var alpha =   x;
    // ctx.globalAlpha = alpha;       
            
    // ctx.fillRect(50, 20, 40, 40);
    // ctx.globalAlpha = 1;
    // ctx.restore();
  }          
  

  socket = io();
  socket.on('connect', function(){
    socket.on('feed', function(data){
      if((g.device_id === data.device_id)&&(data.sensor_id === g.sensor)){
        g.pushPoint(data.timeS,data.data)
      }
    });
  });
};

</script>
  <body class="noselect">
    <div >
      <canvas  id=asd width =800 height=200></canvas>
      <canvas  id=asdi width =800 height=50></canvas>
      <select id=timeScale onchange="setInterval(this.value)">
        <optgroup label = "Choose Time Frame">
          <option value=1.8e+6 >30m</option>
          <option value=7.2e+6 >2h</option>
          <option value=1.44e+7 >4h</option>
          <option value=8.64e+7 selected="selected" >1d</option>
          <option value=1.296e+8>3d</option>
        </optgroup>
      </select>
      <button onclick="goLive()">Go To Live</button>      
      <button onclick="push()">push 25</button>

    </div>
  </body>
</html>
    